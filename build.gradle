/*
 * Bearsampp Module Python - Pure Gradle Build
 *
 * This is a pure Gradle build configuration that replaces the legacy Ant build system.
 * All build logic has been converted to native Gradle tasks.
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release                            - Interactive release (prompts for version)
 *   gradle release -PbundleVersion=3.13.5     - Non-interactive release
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 *   gradle verify                             - Verify build environment
 */

plugins {
    id 'base'
}

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'python')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath
    buildPropertiesFile = file('build.properties').absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'python')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'tools')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // External build base path precedence: build.properties (build.path) -> env(BEARSAMPP_BUILD_PATH) -> default <root>/bearsampp-build
    def buildPathFromProps = (buildProps.getProperty('build.path', '') ?: '').trim()
    def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
    def defaultBuildPath = "${rootDir}/bearsampp-build"
    buildBasePath = buildPathFromProps ? buildPathFromProps : (buildPathFromEnv ? buildPathFromEnv : defaultBuildPath)

    // Shared external tmp tree
    buildTmpPath = file("${buildBasePath}/tmp").absolutePath
    bundleTmpPrepPath = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}").absolutePath
    bundleTmpBuildPath = file("${buildTmpPath}/bundles_build/${bundleType}/${bundleName}").absolutePath
    bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}").absolutePath

    // Final external output path for archives
    moduleBuildOutputPath = file("${buildBasePath}/${bundleType}/${bundleName}/${bundleRelease}").absolutePath
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    logger.warn("Dev path not found: ${ext.devPath}. Some tasks may not work correctly.")
}

// Configure repositories for dependencies
repositories {
    mavenCentral()
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Helper function to find 7-Zip executable
def find7ZipExecutable() {
    // Check environment variable
    def sevenZipHome = System.getenv('7Z_HOME')
    if (sevenZipHome) {
        def exe = file("${sevenZipHome}/7z.exe")
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Check common installation paths
    def commonPaths = [
        'C:/Program Files/7-Zip/7z.exe',
        'C:/Program Files (x86)/7-Zip/7z.exe',
        'D:/Program Files/7-Zip/7z.exe',
        'D:/Program Files (x86)/7-Zip/7z.exe'
    ]

    for (path in commonPaths) {
        def exe = file(path)
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Try to find in PATH
    try {
        def process = ['where', '7z.exe'].execute()
        process.waitFor()
        if (process.exitValue() == 0) {
            def output = process.text.trim()
            if (output) {
                return output.split('\n')[0].trim()
            }
        }
    } catch (Exception e) {
        // Ignore
    }

    return null
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Helper methods for version discovery
def findAvailableVersions = {
    def binDir = new File(projectDir, 'bin')
    def archivedDir = new File(projectDir, 'bin/archived')
    def versions = [] as List<String>

    if (binDir.exists()) {
        versions.addAll(
            (binDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' && it.name != 'archi8ved' }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    if (archivedDir.exists()) {
        versions.addAll(
            (archivedDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    return versions.unique()
}

// Helper: Fetch python.properties from modules-untouched repository
def fetchModulesUntouchedProperties() {
    def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/python.properties"
    
    println "Checking modules-untouched repository..."
    println "Fetching python.properties from modules-untouched repository..."
    println "  URL: ${propsUrl}"
    
    def tempFile = file("${bundleTmpDownloadPath}/python-untouched.properties")
    tempFile.parentFile.mkdirs()
    
    try {
        new URL(propsUrl).withInputStream { input ->
            tempFile.withOutputStream { output ->
                output << input
            }
        }
        
        def props = new Properties()
        tempFile.withInputStream { props.load(it) }
        
        println "  ✓ Successfully loaded ${props.size()} versions from modules-untouched"
        return props
    } catch (Exception e) {
        println "  ✗ Warning: Could not fetch python.properties from modules-untouched: ${e.message}"
        return null
    }
}

// Helper: Download Python binaries from modules-untouched repository
def downloadFromModulesUntouched(String version) {
    def untouchedProps = fetchModulesUntouchedProperties()
    
    if (!untouchedProps) {
        throw new GradleException("Could not fetch python.properties from modules-untouched repository")
    }
    
    def untouchedUrl = untouchedProps.getProperty(version)
    if (!untouchedUrl) {
        throw new GradleException("Version ${version} not found in modules-untouched python.properties")
    }
    
    println "Found version ${version} in modules-untouched python.properties"
    println "Downloading from:"
    println "  ${untouchedUrl}"
    
    def filename = untouchedUrl.substring(untouchedUrl.lastIndexOf('/') + 1)
    def downloadDir = file(bundleTmpDownloadPath)
    downloadDir.mkdirs()
    
    def downloadedFile = file("${downloadDir}/${filename}")
    
    if (!downloadedFile.exists()) {
        println "Downloading to: ${downloadedFile}"
        new URL(untouchedUrl).withInputStream { input ->
            downloadedFile.withOutputStream { output ->
                output << input
            }
        }
        println "Download complete from modules-untouched"
    } else {
        println "Already downloaded: ${downloadedFile.name}"
    }
    
    return downloadedFile
}

// Helper: Extract Python archive
def extractPythonArchive(File archive, String version) {
    def extractDir = file("${bundleTmpPath}/extract/${bundleName}")
    extractDir.mkdirs()
    
    println "Extracting archive..."
    def extractPath = file("${extractDir}/${version}")
    if (extractPath.exists()) {
        delete extractPath
    }
    extractPath.mkdirs()
    
    // Extract using Gradle's zipTree
    copy {
        from zipTree(archive)
        into extractPath
    }
    
    println "Extraction complete"
    
    // Find the Python directory (it might be nested)
    def pythonDir = findPythonDirectory(extractPath)
    if (!pythonDir) {
        throw new GradleException("Could not find Python directory in extracted archive")
    }
    
    println "Found Python directory: ${pythonDir.name}"
    return pythonDir
}

// Helper: Find Python directory containing python.exe
def findPythonDirectory(File searchDir) {
    // Case 1: Check if python.exe is directly in this directory
    def pythonExe = new File(searchDir, 'python.exe')
    if (pythonExe.exists()) {
        return searchDir
    }
    
    // Case 2: Recursively search for a directory containing python.exe
    File found = null
    def stack = new ArrayDeque<File>()
    stack.push(searchDir)
    
    while (!stack.isEmpty() && !found) {
        def current = stack.pop()
        def children = current.listFiles()
        if (children) {
            for (def child : children) {
                if (child.isDirectory()) {
                    def exe = new File(child, 'python.exe')
                    if (exe.exists()) {
                        found = child
                        break
                    }
                    stack.push(child)
                }
            }
        }
    }
    
    return found
}

def latestVersion = { List<String> versions ->
    if (versions.isEmpty()) return null
    return versions.max { a, b ->
        def pa = a.split('\\.').collect { it.isInteger() ? it as int : 0 }
        def pb = b.split('\\.').collect { it.isInteger() ? it as int : 0 }
        def len = Math.max(pa.size(), pb.size())
        for (int i = 0; i < len; i++) {
            def ai = i < pa.size() ? pa[i] : 0
            def bi = i < pb.size() ? pb[i] : 0
            if (ai != bi) return ai <=> bi
        }
        return 0
    }
}

// ============================================================================
// GRADLE NATIVE TASKS
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                  Bearsampp Module Python - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          Build Base:   ${buildBasePath}
          Output Dir:   ${moduleBuildOutputPath}
          Tmp Root:     ${buildTmpPath}
          Tmp Prep:     ${bundleTmpPrepPath}
          Tmp Build:    ${bundleTmpBuildPath}
          Downloads:    ${bundleTmpDownloadPath}

        Java:
          Version:      ${JavaVersion.current()}
          Home:         ${System.getProperty('java.home')}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Python Build Features:
          * Automatic PIP upgrade during build
          * Wheel package download and installation
          * Support for multiple Python versions
          * PyQt5 exclusion handling

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification and validation tasks

        Quick Start:
          gradle tasks                              - List all available tasks
          gradle info                               - Show this information
          gradle release                            - Interactive release build
          gradle release -PbundleVersion=3.13.5     - Non-interactive release
          gradle clean                              - Clean build artifacts
          gradle verify                             - Verify build environment
          gradle listVersions                       - List available Python versions
        """.stripIndent()
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
            println "Cleaned: ${buildDir}"
        }

        // Clean temporary directories
        def tmpDir = file(buildTmpPath)
        if (tmpDir.exists()) {
            delete tmpDir
            println "Cleaned: ${tmpDir}"
        }

        // Clean Gradle-specific temp files
        def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
        if (gradleBundleVersion.exists()) {
            delete gradleBundleVersion
            println "Cleaned: ${gradleBundleVersion.name}"
        }

        println "[SUCCESS] Build artifacts cleaned"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-python..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.gradle'] = file('build.gradle').exists()
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()

        // Check dev directory
        checks['dev directory'] = file(devPath).exists()

        // Check bin directory for Python versions
        def binDir = file("${projectDir}/bin")
        checks['bin directory'] = binDir.exists()

        if (binDir.exists()) {
            def pythonVersions = binDir.listFiles()
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            checks['Python versions available'] = pythonVersions.size() > 0
        }

        // Check for 7z command
        def sevenZipExe = find7ZipExecutable()
        checks['7-Zip available'] = sevenZipExe != null

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release                            - Interactive release"
            println "  gradle release -PbundleVersion=3.13.5     - Non-interactive release"
            println "  gradle listVersions                       - List available Python versions"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// Task: Resolve version (interactive by default; supports -PbundleVersion and '*')
tasks.register('resolveVersion') {
    group = 'build'
    description = 'Resolve bundleVersion (interactive by default, or use -PbundleVersion=*,<ver>)'
    
    def versionProperty = project.findProperty('bundleVersion')

    doLast {
        def supplied = versionProperty as String
        def all = findAvailableVersions().sort { a, b ->
            def pa = a.split('\\.').collect { it.isInteger() ? it as int : 0 }
            def pb = b.split('\\.').collect { it.isInteger() ? it as int : 0 }
            for (int i=0; i<Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }
        
        def inBin = new File(projectDir, 'bin').exists() ? (new File(projectDir, 'bin').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []
        def inArchived = new File(projectDir, 'bin/archived').exists() ? (new File(projectDir, 'bin/archived').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        String resolved
        if (supplied) {
            if (supplied == '*') {
                resolved = latestVersion(all)
                if (!resolved) {
                    throw new GradleException("No versions found under bin/ to resolve latest from.")
                }
                println "Resolved latest version: ${resolved}"
            } else {
                resolved = supplied
            }
        } else {
            println "=".multiply(70)
            println "\nInteractive Release Mode\n"
            println "=".multiply(70)
            println "\nAvailable versions:\n"
            all.eachWithIndex { v, idx ->
                def indexStr = String.format('%2d', idx + 1)
                def tag = inBin.contains(v) && inArchived.contains(v) ? '[bin + bin/archived]' : (inBin.contains(v) ? '[bin]' : (inArchived.contains(v) ? '[bin/archived]' : '[unknown]'))
                println "  ${indexStr}. ${v.padRight(12)} ${tag}"
            }
            println ""
            print "Enter version to build (index or version string): "
            System.out.flush()
            def reader = new BufferedReader(new InputStreamReader(System.in))
            def input = reader.readLine()?.trim()
            if (!input) {
                throw new GradleException("No version specified")
            }
            if (input.isInteger()) {
                def idx = input.toInteger()
                if (idx < 1 || idx > all.size()) {
                    throw new GradleException("Invalid index: ${input}. Choose 1..${all.size()} or enter a version string.")
                }
                resolved = all[idx - 1]
            } else {
                resolved = input
            }
        }

        // Validate existence in bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${resolved}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${resolved}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                def listing = all.collect { "  - ${it}" }.join('\n')
                throw new GradleException("Bundle version not found in bin/ or bin/archived/: ${bundleName}${resolved}\n\nAvailable versions:\n${listing}")
            }
        }

        // Store resolved version
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        propsFile.parentFile.mkdirs()
        propsFile.text = resolved
        println "\nSelected version: ${resolved}\n"
    }
}

// Provider resolves version from either -PbundleVersion or value set by resolveVersion
def bundleVersionProvider = providers.provider {
    def fromProp = project.findProperty('bundleVersion') as String
    if (fromProp) return fromProp
    def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
    if (propsFile.exists()) {
        return propsFile.text.trim()
    }
    return null
}

// Guard task: ensure bundleVersion is resolved before any packaging runs
tasks.register('assertVersionResolved') {
    group = 'build'
    description = 'Fail fast if bundleVersion was not resolved by resolveVersion'
    dependsOn 'resolveVersion'
    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set. Run 'gradle resolveVersion' or invoke 'gradle release -PbundleVersion=<'*'|X.Y.Z>'")
        }
    }
}

// Task: Actual release build logic
tasks.register('releaseBuild') {
    group = 'build'
    description = 'Execute the release build process'
    dependsOn 'resolveVersion'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Helper: Fetch python.properties from modules-untouched repository
        def fetchModulesUntouchedProperties = {
            def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/python.properties"
            
            println "Checking modules-untouched repository..."
            println "Fetching python.properties from modules-untouched repository..."
            println "  URL: ${propsUrl}"
            
            def tempFile = file("${bundleTmpDownloadPath}/python-untouched.properties")
            tempFile.parentFile.mkdirs()
            
            try {
                new URL(propsUrl).withInputStream { input ->
                    tempFile.withOutputStream { output ->
                        output << input
                    }
                }
                
                def props = new Properties()
                tempFile.withInputStream { props.load(it) }
                
                println "  ✓ Successfully loaded ${props.size()} versions from modules-untouched"
                return props
            } catch (Exception e) {
                println "  ✗ Warning: Could not fetch python.properties from modules-untouched: ${e.message}"
                return null
            }
        }

        // Helper: Download Python binaries from modules-untouched repository
        def downloadFromModulesUntouched = { String version ->
            def untouchedProps = fetchModulesUntouchedProperties()
            
            if (!untouchedProps) {
                throw new GradleException("Could not fetch python.properties from modules-untouched repository")
            }
            
            def untouchedUrl = untouchedProps.getProperty(version)
            if (!untouchedUrl) {
                throw new GradleException("Version ${version} not found in modules-untouched python.properties")
            }
            
            println "Found version ${version} in modules-untouched python.properties"
            println "Downloading from:"
            println "  ${untouchedUrl}"
            
            def filename = untouchedUrl.substring(untouchedUrl.lastIndexOf('/') + 1)
            def downloadDir = file(bundleTmpDownloadPath)
            downloadDir.mkdirs()
            
            def downloadedFile = file("${downloadDir}/${filename}")
            
            if (!downloadedFile.exists()) {
                println "Downloading to: ${downloadedFile}"
                new URL(untouchedUrl).withInputStream { input ->
                    downloadedFile.withOutputStream { output ->
                        output << input
                    }
                }
                println "Download complete from modules-untouched"
            } else {
                println "Already downloaded: ${downloadedFile.name}"
            }
            
            return downloadedFile
        }

        // Helper: Extract Python archive
        def extractPythonArchive = { File archive, String version ->
            def extractDir = file("${buildTmpPath}/extract/${bundleName}")
            extractDir.mkdirs()
            
            println "Extracting archive..."
            def extractPath = file("${extractDir}/${version}")
            if (extractPath.exists()) {
                delete extractPath
            }
            extractPath.mkdirs()
            
            // Extract using Gradle's zipTree or 7z
            if (archive.name.endsWith('.7z')) {
                // Use 7z to extract
                def sevenZipExe = find7ZipExecutable()
                if (!sevenZipExe) {
                    throw new GradleException("7-Zip not found. Cannot extract .7z archive: ${archive.name}")
                }
                
                def command = [
                    sevenZipExe,
                    'x',
                    archive.absolutePath,
                    "-o${extractPath.absolutePath}",
                    '-y'
                ]
                
                def process = new ProcessBuilder(command as String[])
                    .redirectErrorStream(true)
                    .start()
                
                process.inputStream.eachLine { line ->
                    // Suppress output unless there's an error
                }
                
                def exitCode = process.waitFor()
                if (exitCode != 0) {
                    throw new GradleException("7-Zip extraction failed with exit code: ${exitCode}")
                }
            } else {
                // Use Gradle's zipTree for .zip files
                copy {
                    from zipTree(archive)
                    into extractPath
                }
            }
            
            println "Extraction complete"
            
            // Find the Python directory (it might be nested)
            def pythonDir = findPythonDirectory(extractPath)
            if (!pythonDir) {
                throw new GradleException("Could not find Python directory in extracted archive")
            }
            
            println "Found Python directory: ${pythonDir.name}"
            return pythonDir
        }

        // Resolve bundle path from bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                throw new GradleException("Bundle folder not found in bin/ or bin/archived/: ${bundleName}${versionToBuild}")
            }
        }

        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        println "=".multiply(70)
        println "\nBuilding ${bundleName} ${bundleVersion}\n"
        println "=".multiply(70)
        println "\nBundle path: ${bundlePath}"

        // Prepare Python directory
        def pythonPrepPath = new File(bundleTmpPrepPath, bundleFolder)
        delete pythonPrepPath
        pythonPrepPath.mkdirs()

        // Determine source paths for Python binaries
        def pythonSrcFinal = bundlePath
        
        // Check if python.exe exists in the bundle directory
        def pythonExe = file("${bundlePath}/python.exe")
        if (!pythonExe.exists()) {
            // Python binaries not found - need to download from modules-untouched
            println "\nPython binaries not found"
            println "Downloading Python ${bundleVersion}..."
            println ""
            
            try {
                // Download and extract Python binaries
                def downloadedArchive = downloadFromModulesUntouched(bundleVersion)
                pythonSrcFinal = extractPythonArchive(downloadedArchive, bundleVersion)
                
                println ""
                println "NOTE: Version ${bundleVersion} was sourced from modules-untouched."
                println "Source folder: ${pythonSrcFinal}"
            } catch (Exception e) {
                throw new GradleException("""
                    Failed to download Python binaries: ${e.message}
                    
                    You can manually download and extract Python binaries to:
                      ${bundlePath}/
                    
                    Or check that version ${bundleVersion} exists in modules-untouched python.properties
                """.stripIndent())
            }
        }
        
        // Verify python.exe exists
        pythonExe = file("${pythonSrcFinal}/python.exe")
        if (!pythonExe.exists()) {
            throw new GradleException("python.exe not found at ${pythonExe}")
        }

        println "\nCopying Python files..."
        
        // For WinPython, we need the entire extracted directory structure
        // which includes python/, scripts/, notebooks/, settings/, etc.
        def winPythonRoot = pythonSrcFinal.parent
        if (winPythonRoot && file(winPythonRoot).exists()) {
            println "Copying complete WinPython distribution..."
            copy {
                from winPythonRoot
                into pythonPrepPath
            }
        } else {
            // Fallback: just copy the python directory
            copy {
                from pythonSrcFinal
                into pythonPrepPath
            }
        }
        
        // Overlay configuration files from bin/ directory (temp copy for PIP/wheel operations)
        println "Overlaying bundle files from bin directory..."
        copy {
            from bundlePath
            into pythonPrepPath
            exclude 'pyqt5/**'
        }

        // Check if we have python.bat to run PIP upgrade (matching original build.xml)
        def pythonBat = file("${pythonPrepPath}/bin/python.bat")
        if (pythonBat.exists()) {
            println "Upgrading PIP..."
            
            // Upgrade PIP using bin/python.bat (matching original build.xml)
            def pipUpgrade = ["cmd", "/c", "python.bat", "-m", "pip", "install", "--upgrade", "pip"]
            def pipProcess = new ProcessBuilder(pipUpgrade as String[])
                .directory(file("${pythonPrepPath}/bin"))
                .redirectErrorStream(true)
                .start()
            
            pipProcess.inputStream.eachLine { line ->
                if (line.trim()) println "  ${line}"
            }
            
            def pipExitCode = pipProcess.waitFor()
            if (pipExitCode != 0) {
                throw new GradleException("PIP upgrade failed with exit code: ${pipExitCode}")
            }

            // Download and install wheel
            def wheelDir = file("${pythonPrepPath}/wheel")
            if (wheelDir.exists()) {
                def wheelProps = file("${wheelDir}/wheel.properties")
                if (wheelProps.exists()) {
                    def props = new Properties()
                    wheelProps.withInputStream { props.load(it) }
                    def wheelUrl = props.getProperty('wheel')
                    
                    if (wheelUrl) {
                        println "Downloading Wheel..."
                        def wheelFile = wheelUrl.tokenize('/').last()
                        def wheelDest = file("${wheelDir}/${wheelFile}")
                        
                        // Download wheel file if it doesn't exist
                        if (!wheelDest.exists()) {
                            wheelDest.parentFile.mkdirs()
                            new URL(wheelUrl).withInputStream { input ->
                                wheelDest.withOutputStream { output ->
                                    output << input
                                }
                            }
                        }
                        
                        // Install wheel using install.bat (matching original build.xml)
                        println "Installing Wheel..."
                        def installProcess = new ProcessBuilder(["cmd", "/c", "install.bat"] as String[])
                            .directory(wheelDir)
                            .redirectErrorStream(true)
                            .start()
                        
                        installProcess.inputStream.eachLine { line ->
                            if (line.trim()) println "  ${line}"
                        }
                        
                        def installExitCode = installProcess.waitFor()
                        if (installExitCode != 0) {
                            throw new GradleException("Wheel installation failed with exit code: ${installExitCode}")
                        }
                    }
                }
                
                // Clean up wheel directory
                wheelDir.deleteDir()
            }
        } else {
            println "Skipping PIP upgrade (python.bat not found)"
            println "Skipping wheel processing (python.bat not found)"
        }

        // Copy to bundles_build directory
        def bundlesBuildPath = file("${bundleTmpBuildPath}/${bundleFolder}")
        delete bundlesBuildPath
        bundlesBuildPath.mkdirs()
        
        println "Copying to bundles_build directory..."
        copy {
            from pythonPrepPath
            into bundlesBuildPath
        }
        
        println "\nNon-zip version available at: ${bundlesBuildPath}"

        // Store paths in a file for later use (avoid using project.ext at execution time)
        def pathsFile = file("${buildTmpPath}/.gradle-build-paths")
        pathsFile.parentFile.mkdirs()
        pathsFile.text = "preparedBundlePath=${pythonPrepPath.absolutePath}\nbuildBundlePath=${bundlesBuildPath.absolutePath}"
    }
}

def externalOutputDir = file("${moduleBuildOutputPath}")

// 7z packager
tasks.register('packageRelease7z') {
    group = 'build'
    description = 'Package release into a .7z archive (includes version folder at root)'
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        externalOutputDir.mkdirs()
        def archiveName = "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.7z"
        def archiveFile = new File(externalOutputDir, archiveName)

        if (archiveFile.exists()) {
            delete archiveFile
        }

        println "  5. Creating release archive..."
        println "\nPreparing archive..."
        println "Compressing ${bundleFolder} to ${archiveName}..."

        // Find 7z executable
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("""
                7-Zip not found. Please install 7-Zip or set 7Z_HOME environment variable.
                
                Download from: https://www.7-zip.org/
                Or set 7Z_HOME to your 7-Zip installation directory.
            """.stripIndent())
        }

        println "Using 7-Zip: ${sevenZipExe}"
        println ""

        def command = [
            sevenZipExe,
            'a',
            '-t7z',
            archiveFile.absolutePath.toString(),
            bundleFolder
        ]

        def process = new ProcessBuilder(command as String[])
            .directory(prepRoot)
            .redirectErrorStream(true)
            .start()

        process.inputStream.eachLine { line ->
            if (line.trim()) println line
        }

        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7-Zip compression failed with exit code: ${exitCode}")
        }

        println ""
        println "Archive created: ${archiveFile}"
    }
}

// Zip packager
tasks.register('packageReleaseZip', Zip) {
    group = 'build'
    description = 'Package release into a .zip archive (includes version folder at root)'
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doFirst {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        archiveFileName.set("bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.zip")
        destinationDirectory.set(externalOutputDir)

        from(prepRoot) {
            include "${bundleFolder}/**"
        }

        println "  5. Creating release archive..."
        println "\nPreparing archive..."
        println "Compressing ${bundleFolder} to ${archiveFileName.get()}..."
    }
}

// Dispatcher task
def archiveFormat = (bundleFormat ?: '7z').toLowerCase()
tasks.register('packageRelease') {
    group = 'build'
    description = 'Package release into archive (7z or zip) including the version folder at root'
    dependsOn 'resolveVersion', 'releaseBuild', 'assertVersionResolved'
    dependsOn archiveFormat == '7z' ? 'packageRelease7z' : 'packageReleaseZip'
}

// Task: Generate hash files
tasks.register('generateHashes') {
    group = 'build'
    description = 'Generate hash sidecar files for the packaged archive'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }
        
        def extFormat = (bundleFormat ?: '7z').toLowerCase()
        def archive = new File(externalOutputDir, "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.${extFormat}")
        if (!archive.exists()) {
            throw new GradleException("Archive not found for hashing: ${archive}")
        }

        println "\nGenerating hash files..."

        def writeHash = { String algo, String ext ->
            def h = calculateHash(archive, algo)
            def out = new File(archive.absolutePath + ".${ext}")
            out.text = "${h} ${archive.name}\n"
            println "  Created: ${out.name}"
        }

        writeHash('MD5', 'md5')
        writeHash('SHA-1', 'sha1')
        writeHash('SHA-256', 'sha256')
        writeHash('SHA-512', 'sha512')
        
        // Print final success message
        def bundleFolder = "${bundleName}${versionToBuild}"
        def outputDir = file("${bundleTmpBuildPath}/${bundleFolder}")
        
        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println "Output directory: ${outputDir.absolutePath}"
        println "Archive: ${archive.absolutePath}"
        println "=".multiply(70)
    }
}

// Task: Cleanup temporary Gradle-specific files after build
tasks.register('cleanupTempFiles') {
    group = 'build'
    description = 'Cleanup temporary Gradle-specific files after build'
    
    doLast {
        def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
        if (gradleBundleVersion.exists()) {
            delete gradleBundleVersion
        }
    }
}

// Task: Main release task
tasks.register('release') {
    group = 'build'
    description = 'Build release package (interactive by default; -PbundleVersion=* or X.Y.Z for non-interactive)'
    dependsOn 'clean', 'resolveVersion', 'packageRelease'
    finalizedBy 'generateHashes', 'cleanupTempFiles'
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        def releasesFile = file('releases.properties')
        if (!releasesFile.exists()) {
            println "releases.properties not found"
            return
        }

        def releases = new Properties()
        releasesFile.withInputStream { releases.load(it) }

        println "\nAvailable Python Releases:"
        println "-".multiply(80)
        releases.sort { it.key }.each { version, url ->
            println "  ${version.padRight(15)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${releases.size()}"
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available Python bundle versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        def archivedDir = file("${projectDir}/bin/archived")

        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        def inBin = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []

        def inArchived = archivedDir.exists() ? (archivedDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        def allVersions = (inBin + inArchived).toSet().toList().sort { a, b ->
            def pa = a.split('\\.').collect { it.isInteger() ? it as int : 0 }
            def pb = b.split('\\.').collect { it.isInteger() ? it as int : 0 }
            for (int i = 0; i < Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }

        println "\nAvailable ${bundleName} versions (index, version, location):"
        println "-".multiply(60)
        allVersions.eachWithIndex { v, idx ->
            def tag
            def inBinFlag = inBin.contains(v)
            def inArchivedFlag = inArchived.contains(v)
            if (inBinFlag && inArchivedFlag) {
                tag = "[bin + bin/archived]"
            } else if (inBinFlag) {
                tag = "[bin]"
            } else if (inArchivedFlag) {
                tag = "[bin/archived]"
            } else {
                tag = "[unknown]"
            }
            def indexStr = String.format('%2d', idx + 1)
            println "  ${indexStr}. ${v.padRight(12)} ${tag}"
        }
        println "-".multiply(60)
        println "Total versions: ${allVersions.size()}"
        if (!allVersions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${allVersions.last()}"
        }
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println "Validating build.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: Validate Python version structure
tasks.register('validatePythonVersion') {
    group = 'verification'
    description = 'Validate Python version directory structure (use -PbundleVersion=X.X.X)'

    doLast {
        def versionToValidate = project.findProperty('bundleVersion')

        if (!versionToValidate) {
            println "[ERROR] Please specify a version using -PbundleVersion=X.X.X"
            println "\nExample: gradle validatePythonVersion -PbundleVersion=3.13.5"
            throw new GradleException("Bundle version not specified")
        }

        def versionDir = file("${projectDir}/bin/${bundleName}${versionToValidate}")

        if (!versionDir.exists()) {
            println "[ERROR] Version directory not found: ${versionDir}"
            throw new GradleException("Python version ${versionToValidate} not found")
        }

        println "Validating Python version ${versionToValidate}..."
        println "-".multiply(60)

        def checks = [:]

        // Check required directories
        checks['bin directory'] = file("${versionDir}/bin").exists()
        checks['wheel directory'] = file("${versionDir}/wheel").exists()

        // Check required files
        checks['bearsampp.conf'] = file("${versionDir}/bearsampp.conf").exists()
        checks['bin/python.bat'] = file("${versionDir}/bin/python.bat").exists()

        // Check wheel configuration
        def wheelDir = file("${versionDir}/wheel")
        if (wheelDir.exists()) {
            checks['wheel.properties'] = file("${wheelDir}/wheel.properties").exists()
            checks['install.bat'] = file("${wheelDir}/install.bat").exists()

            def wheelProps = file("${wheelDir}/wheel.properties")
            if (wheelProps.exists()) {
                def props = new Properties()
                wheelProps.withInputStream { props.load(it) }
                checks['wheel URL defined'] = props.containsKey('wheel') && !props.getProperty('wheel').trim().isEmpty()
            }
        }

        println "\nValidation Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] Python version ${versionToValidate} structure is valid"
        } else {
            println "\n[WARNING] Some validation checks failed"
            throw new GradleException("Python version validation failed")
        }
    }
}

// Task: Display wheel information for a Python version
tasks.register('showWheelInfo') {
    group = 'help'
    description = 'Display wheel package information for a Python version (use -PbundleVersion=X.X.X)'

    doLast {
        def versionToCheck = project.findProperty('bundleVersion')

        if (!versionToCheck) {
            println "[ERROR] Please specify a version using -PbundleVersion=X.X.X"
            println "\nExample: gradle showWheelInfo -PbundleVersion=3.13.5"
            return
        }

        def versionDir = file("${projectDir}/bin/${bundleName}${versionToCheck}")
        def wheelDir = file("${versionDir}/wheel")

        if (!wheelDir.exists()) {
            println "[ERROR] Wheel directory not found for version ${versionToCheck}"
            return
        }

        println "\nWheel Information for Python ${versionToCheck}:"
        println "=".multiply(70)

        def wheelProps = file("${wheelDir}/wheel.properties")
        if (wheelProps.exists()) {
            def props = new Properties()
            wheelProps.withInputStream { props.load(it) }

            def wheelUrl = props.getProperty('wheel', 'Not defined')
            def wheelFile = wheelUrl.tokenize('/').last()

            println "  Wheel URL:  ${wheelUrl}"
            println "  Wheel File: ${wheelFile}"
            println "  Location:   ${wheelDir}"
        } else {
            println "  [WARNING] wheel.properties not found"
        }

        def installBat = file("${wheelDir}/install.bat")
        if (installBat.exists()) {
            println "\n  Install Script: ${installBat}"
            println "  Content:"
            println "  " + "-".multiply(66)
            installBat.eachLine { line ->
                println "  ${line}"
            }
        }

        println "=".multiply(70)
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module Python - Pure Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
